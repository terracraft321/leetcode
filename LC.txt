https://neetcode.io/

Blind75
----------------------
Day 1.

217. Contains duplicate. Use a hash set

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)

or


class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hashset = set()

	for n in nums:
		if n in hashset:
			return True
		hashset.add(n)
	return False

1.

class Solution:
	def containsDuplciate(self, nums: List[int]) -> bool:
		hashset = set()

	for in n nums:
		if n in hashset:
			return true
		hashset.add(n)
	return false

Time and space complexity: O(n), O(n)


2.

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)




------------------------------------------------------------------

242. Valid Anagram.

Use a hashmap or array.

class Solution:
	def isAnagram(self, s: str, t: str) -> bool:
	return Counter(s) == Counter(t)
	
	if len(s) != len(t):
	return False
	countS, countT = {}, {}
	
	for i in range(len(s)):
	countS[s[i]] = 1 + countS.get(s[i], 0)
	countT[t[i]] = 1 + countT.get(t[i], 0)
	for c in countS:
	if countS[c] != countT.get(c, 0):
	return False

	return True

Time complexity
O(s+t)
Need extra memory.

sorted Counter(s) == Counter(t)


Memory: O(1)
Time complexity: O(n log n)


---------

class solution:
	def twoSum(self, nums: List[int], target: int) -> List[
 	prevMap = {} 


for i, n in enumerate(nums):
	diff = target - n
	if diff in prevMap:
		return [prevMap[diff], i]
	prevMap{n] = i
return



class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}  # val -> index

        for i, n in enumerate(nums):
            diff = target - n
            if diff in prevMap:
                return [prevMap[diff], i]
            prevMap[n] = i

o(n)
o(n)

---------------
49. group-anagrams

Use a hash map, key:value pair 
count all charachters, key -> which strings have this pattern of count, value, eat, tea, eat
Big of (m*n*26) constant is dropped 
O(m*n)


Class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
	ans = collections.defaultdict(list)

	for s in strs:
		count = [0] * 26 # Array consisting of all lower case charachters  a...z
		for c in s:
			count[ord(c) - ord('a')] += 1 # mapping a to index 0, mapping z to 25, ascii - lowercase a, 80-80, 81-80...
		ans[tuple(count)].append(s)  # lists cannot be keys, tuples are non mutable  # state cannot be modified after it is created, a bit like a constant
	return ans.values()  # of keys 

	# O(m * n)
	# m, number of strings given
	# n, average length of string 

---------------------------

347. Top K Frequent Elements

#: Use Bucket Sort in a unbounded manner, since our values go from 1-100 or even a million
#: in bounded it would be just 1-10, usually how it's taught
#: In the first one you'd just have count and frequency
#: Here we count the number of elements in the input array, and use that value bound our new array
#: So we only count the values that we have to count, which makes our problem in scope smaller.
#: Then we only count the frequency for every number
#: Then we traverse the list from right to left, from -1, to zero, and we decrement by -1
#: And we just return largest K amounts, by how many times the questions ask ## or return the whole array.


class Solution: 
	def topKFrequent(self, nums: List[int], k: int) -> List[int]:
		count = {}
		freq = [[] for i in range(len(nums) + 1)]

		# init counts, and frequency 
		for n in nums:
			count [n] = 1 + count.get(n, 0) # 0 default value for count, how many times each number in count occurs
		for n, c in count.items(): # it returns every single key value pair, we've added to our dictionary.
			freq[c].append(n) # for every key value pair, number and count, for count (index) we append to that list, n, value N occurs C times. - how many times they occur, so I think that's what what let us have these both arrays                                     together. 

		res = []  # will reach size of K at some point, because we have K values in our input array nums. 
		for i in range(len(freq) - 1, 0, -1):   # -1 the index we start at, 0 the index we stop at, -1 we decrement so we go towards the left <-- 
			    for n in freq[i]: #anything in I is another sublist, so it could be empty or it could have an value, that's frequency 
			        res.append(n) # we get the values that occur the most by frequency, and we append it into our output list 
			        if len(res) == k: # if the length of result matches K, 
			            return res # return result, it has to end up at some point, no need for return state outside of the loop. 

			# with heap, O(klogn)
			# with this trick, O(n) time 
		-----------------------------------------



		238. Product of Array Except Self

		# product, multiplication
		# in place manipulation of the array 

class Solution:
    def productExceptSelf(self, nums:  List[int]) -> list[int]:
        res = [1] * (len(nums))

        prefix = 1  #prefix array 
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]  #multiply left to right
        postfix = 1 #turn prefix into postfix
        for i in range(len(nums) - 1, -1, -1): #multiply right to left
            res[i] *= postfix
            postfix *= nums[i] # update values 
        return res
		
		#o(n) without extra memory
		--------------------------------------------

659 Â· Encode and Decode Strings.
# string manipulation
# pound symbol
# read length of string
# in place modification of array 
		
		class Solution:
    """
    @param: strs: a list of strings
    @return: encodes a list of strings to a single string.
    """

    def encode(self, strs):
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    """
    @param: str: A string
    @return: dcodes a single string to a list of strings
    """

    def decode(self, str):
        res, i = [], 0

        while i < len(str):
            j = i
            while str[j] != "#":
                j += 1
            length = int(str[i:j])
            res.append(str[j + 1 : j + 1 + length])
            i = j + 1 + length
        return res
	



----------------------------------------------------------------------------------------
128. Longest Consecutive Sequence


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0
        
        for n in nums:
            # check if it's a start of a sequence
            if (n - 1) not in numSet:
                length = 1 
                while (n + length) in numSet:
                        length += 1
                longest = max(length, longest)
        return longest

-----------------------------------------------------

valid-palindrome

class Solution:
    def isPalindrome(self, s: str) -> bool:
        if s != s[::-1]:
            return True
        else: 
            return False

Works for 378/420

:) good enough
---------------------------------------------

class Solution:
    def isPalindrome(self, s: str) -> bool:
        newStr = ""
        
        for c in s: 
            if c.isalnum():
                newStr += c.lower()
        return newStr == newStr[::-1]
----------------------------------------------------------
