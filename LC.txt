https://neetcode.io/

Blind75
----------------------
Day 1.

217. Contains duplicate. Use a hash set

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)

or


class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hashset = set()

	for n in nums:
		if n in hashset:
			return True
		hashset.add(n)
	return False

1.

class Solution:
	def containsDuplciate(self, nums: List[int]) -> bool:
		hashset = set()

	for in n nums:
		if n in hashset:
			return true
		hashset.add(n)
	return false

Time and space complexity: O(n), O(n)


2.

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)




------------------------------------------------------------------

242. Valid Anagram.

Use a hashmap or array.

class Solution:
	def isAnagram(self, s: str, t: str) -> bool:
	return Counter(s) == Counter(t)
	
	if len(s) != len(t):
	return False
	countS, countT = {}, {}
	
	for i in range(len(s)):
	countS[s[i]] = 1 + countS.get(s[i], 0)
	countT[t[i]] = 1 + countT.get(t[i], 0)
	for c in countS:
	if countS[c] != countT.get(c, 0):
	return False

	return True

Time complexity
O(s+t)
Need extra memory.

sorted Counter(s) == Counter(t)


Memory: O(1)
Time complexity: O(n log n)


---------

class solution:
	def twoSum(self, nums: List[int], target: int) -> List[
 	prevMap = {} 


for i, n in enumerate(nums):
	diff = target - n
	if diff in prevMap:
		return [prevMap[diff], i]
	prevMap{n] = i
return



class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}  # val -> index

        for i, n in enumerate(nums):
            diff = target - n
            if diff in prevMap:
                return [prevMap[diff], i]
            prevMap[n] = i

o(n)
o(n)

---------------
49. group-anagrams

Use a hash map, key:value pair 
count all charachters, key -> which strings have this pattern of count, value, eat, tea, eat
Big of (m*n*26) constant is dropped 
O(m*n)


Class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
	ans = collections.defaultdict(list)

	for s in strs:
		count = [0] * 26 # Array consisting of all lower case charachters  a...z
		for c in s:
			count[ord(c) - ord('a')] += 1 # mapping a to index 0, mapping z to 25, ascii - lowercase a, 80-80, 81-80...
		ans[tuple(count)].append(s)  # lists cannot be keys, tuples are non mutable  # state cannot be modified after it is created, a bit like a constant
	return ans.values()  # of keys 

	# O(m * n)
	# m, number of strings given
	# n, average length of string 

---------------------------

347. Top K Frequent Elements

#: Use Bucket Sort in a unbounded manner, since our values go from 1-100 or even a million
#: in bounded it would be just 1-10, usually how it's taught
#: In the first one you'd just have count and frequency
#: Here we count the number of elements in the input array, and use that value bound our new array
#: So we only count the values that we have to count, which makes our problem in scope smaller.
#: Then we only count the frequency for every number
#: Then we traverse the list from right to left, from -1, to zero, and we decrement by -1
#: And we just return largest K amounts, by how many times the questions ask ## or return the whole array.


class Solution: 
	def topKFrequent(self, nums: List[int], k: int) -> List[int]:
		count = {}
		freq = [[] for i in range(len(nums) + 1)]

		# init counts, and frequency 
		for n in nums:
			count [n] = 1 + count.get(n, 0) # 0 default value for count, how many times each number in count occurs
		for n, c in count.items(): # it returns every single key value pair, we've added to our dictionary.
			freq[c].append(n) # for every key value pair, number and count, for count (index) we append to that list, n, value N occurs C times. - how many times they occur, so I think that's what what let us have these both arrays                                     together. 

		res = []  # will reach size of K at some point, because we have K values in our input array nums. 
		for i in range(len(freq) - 1, 0, -1):   # -1 the index we start at, 0 the index we stop at, -1 we decrement so we go towards the left <-- 
			    for n in freq[i]: #anything in I is another sublist, so it could be empty or it could have an value, that's frequency 
			        res.append(n) # we get the values that occur the most by frequency, and we append it into our output list 
			        if len(res) == k: # if the length of result matches K, 
			            return res # return result, it has to end up at some point, no need for return state outside of the loop. 

			# with heap, O(klogn)
			# with this trick, O(n) time 
		-----------------------------------------



		238. Product of Array Except Self

		# product, multiplication
		# in place manipulation of the array 

class Solution:
    def productExceptSelf(self, nums:  List[int]) -> list[int]:
        res = [1] * (len(nums))

        prefix = 1  #prefix array 
        for i in range(len(nums)):
            res[i] = prefix
            prefix *= nums[i]  #multiply left to right
        postfix = 1 #turn prefix into postfix
        for i in range(len(nums) - 1, -1, -1): #multiply right to left
            res[i] *= postfix
            postfix *= nums[i] # update values 
        return res
		
		#o(n) without extra memory
		--------------------------------------------

659 Â· Encode and Decode Strings.
# string manipulation
# pound symbol
# read length of string
# in place modification of array 
		
		class Solution:
    """
    @param: strs: a list of strings
    @return: encodes a list of strings to a single string.
    """

    def encode(self, strs):
        res = ""
        for s in strs:
            res += str(len(s)) + "#" + s
        return res

    """
    @param: str: A string
    @return: dcodes a single string to a list of strings
    """

    def decode(self, str):
        res, i = [], 0

        while i < len(str):
            j = i
            while str[j] != "#":
                j += 1
            length = int(str[i:j])
            res.append(str[j + 1 : j + 1 + length])
            i = j + 1 + length
        return res
	



----------------------------------------------------------------------------------------
128. Longest Consecutive Sequence


class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0
        
        for n in nums:
            # check if it's a start of a sequence
            if (n - 1) not in numSet:
                length = 1 
                while (n + length) in numSet:
                        length += 1
                longest = max(length, longest)
        return longest

-----------------------------------------------------

valid-palindrome

class Solution:
    def isPalindrome(self, s: str) -> bool:
        if s != s[::-1]:
            return True
        else: 
            return False

Works for 378/420

:) good enough
---------------------------------------------

class Solution:
    def isPalindrome(self, s: str) -> bool:
        newStr = ""
        
        for c in s: 
            if c.isalnum():
                newStr += c.lower()
        return newStr == newStr[::-1]
----------------------------------------------------------
15. 3Sum

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, a in enumerate(nums):
            if i > 0 and a == nums[i - 1]:
                continue

            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    while nums[l] == nums[l - 1] and l < r:
                        l += 1
        return res
--------------------------------------------------------------------

res = 0 
l, r = 0, len(height) - 1

while l < r: 
    area = (r - 1) * min(height[l], height[r])
    res = max(res, area)

    if height[l] < height[r]:
        l += 1
    else:
        r -= 1

    return res

    #O(n)

    -------------


    class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()

        for i, a in enumerate(nums):
            if i > 0 and a == nums[i - 1]:
                continue

            l, r = i + 1, len(nums) - 1
            while l < r:
                threeSum = a + nums[l] + nums[r]
                if threeSum > 0:
                    r -= 1
                elif threeSum < 0:
                    l += 1
                else:
                    res.append([a, nums[l], nums[r]])
                    l += 1
                    while nums[l] == nums[l - 1] and l < r:
                        l += 1
        return result

        -------------

        : calculate area
        : bruteforce
        : move pillar, left to right with steps
        : and then in half steps, in a way from right to left
        : stop until we have found our area, without spilling water.

class Solution:
    def maxArea(self, height: List[int]) -> int:
        l = 0
        r = len(height)-1
        res = 0
        while l < r:
            area = (r - l) * min(height[l], height[r])
            res = max(area,res)
            if height[l]<height[r]:
                l = l+1
            else:
                r = r-1
        return res

this works 
https://leetcode.com/problems/container-with-most-water/discuss/1038263/Python-Solution
------------------------

121. Best Time to Buy and Sell Stock

: Left pointer, right pointer

class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        
        l = 0
        for r in range(1, len(prices)):
            if prices[r] < prices[l]:
                l = r
            res = max(res, prices[r] - prices[l])
        return res 

---------------------------

3. Longest Substring Without Repeating Characters
: Sliding window 

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        charSet = set()
        l = 0 
        res = 0 
        
        for r in range(len(s)):
            while s[r] in charSet:
                charSet.remove(s[l])
                l += 1
            charSet.add(s[r])
            res = max(res, r - l + 1)
        return res

--------------------------------

424. Longest Repeating Character Replacement

: sliding window as well IG

class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        count = {}
        res = 0
        
        l = 0
        maxf = 0
        for r in range(len(s)):
            count[s[r]] = 1 + count.get(s[r], 0)
            maxf= max(maxf, count[s[r]])
            
            while (r - l + 1) - maxf > k:
                count[s[l]] -= 1
                l += 1
                
            res = max(res, r - l + 1)
        return res

        ## O(1) ig 

-----------------------------------

76. Minimum Window Substring
: two hashtables, comparison, while loop, compare counts
: substring problem
: sliding window

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if t == "":
            return ""

        countT, window = {}, {}
        for c in t:
            countT[c] = 1 + countT.get(c, 0)

        have, need = 0, len(countT)
        res, resLen = [-1, -1], float("infinity")
        l = 0
        for r in range(len(s)):
            c = s[r]
            window[c] = 1 + window.get(c, 0)

            if c in countT and window[c] == countT[c]:
                have += 1

            while have == need:
                # update our result
                if (r - l + 1) < resLen:
                    res = [l, r]
                    resLen = r - l + 1
                # pop from the left of our window
                window[s[l]] -= 1
                if s[l] in countT and window[s[l]] < countT[s[l]]:
                    have -= 1
                l += 1
        l, r = res
        return s[l : r + 1] if resLen != float("infinity") else ""

        -------------------------------------------------------------------

20. Valid Parentheses

# use a stack
# if opening and closing matching, pop them,
# if not possible return false ig? 

class Solution:
    def isValid(self, s: str) -> bool:
        Map = {")": "(", "]": "[", "}": "{"}
        stack = []
        
        for c in s:
            if c not in Map:
                stack.append(c)
                continue
            if not stack or stack[-1] != Map[c]:
                return False
            stack.pop() 
            
        return not stack     


------------------------------------------------

33. Search in Rotated Sorted Array
: left pointer and right pointer, linear search since the array is sorted? 

class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l <= r:
            mid = (l + r) // 2
            if target == nums[mid]:
                return mid
            #left sorted portion
            if nums[l] <= nums[mid]:
                if target > nums[mid] or target < nums[l]:
                    l = mid + 1
                else:
                    r = mid - 1
                    #right sorted protio
            else: 
                if target < nums[mid] or target > nums[r]:
                    r = mid - 1 
                else: 
                    l = mid + 1 
        return -1 

# Time complexity: Binary search: O(n log n)
# O(n) also possible but not as efficient for large inputs. 

---------------------------------------------------------------------

206. Reverse a linked list 
: Iterate through the list moving the values over.
: Iterative solution 

: while curr
: temp = curr.next
: curr.next = prev ( we make a temp variable, move old value into our temp)
: prev = curr (we move old value into current)
: curr = temp (we take the value from temp and set it as current)

: 123
: 3 temp
: 32
: tmp 1 
: 321  
: I guess

class Solution: 
    def reverseList(self, head: ListNode) -> ListNode: 
        prev, curr = None, head # init list 

        while curr: # while loop 
            nxt = curr.next #  temporary variable 
            curr.next = prev # we move previous value forward 
            prev = curr # the value before it becomes the new current value we're looking at 
            curr = nxt # we move current value forward 
        return prev

# Time complexity: O(n)
# Space complexity: O(1)
# Recursive is mem is o(1) needs extra mem though.
-------------------------------------

206. Reverse a linked list 
: Recursive solution 
: Keep track of head
: Swap values with the NewHead
: Pointers going to the opposite direction from the end of the list

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:

        if not head:
            return None 

        newHead = head
        if head.next:
            newHead = self.reverseList(head.next)
            head.next.next = head 
        head.next = None 
        
        return newHead 
        # size 2, recursive call size 2, O(n) memory

--------------------------------------------------------
21. Merge Two Sorted Lists

Merge Two Sorted Lists. 

# Make a new list out of the two
# dummy list 
# tail of the list is dummy

# While loop through list 1 and 2 
# If list 1 is smaller than list 2 value
# Next tail is in list 1 -> 
# otherwise update the list with lists 2 value
# if list 1 or 2 is empty, set the tail to the current list
# return dummy.next 

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy = ListNode()
        tail = dummy

        while list1 and list2:
            if list1.val < list2.val:
                tail.next = list1
                list1 = list1.next
            else:
                tail.next = list2
                list2 = list2.next
            tail = tail.next

        if list1:
            tail.next = list1
        elif list2:
            tail.next = list2

        return dummy.next
----------------------------------------------------------------------------------------
143. Reorder List

(in place)
# slow pointer and fast pointer
# find the middle of the list
# reverse 2nd half
# then merge both

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reorderList(self, head: Optional[ListNode]) -> None:
        # find middle
        slow, fast = head, head.next
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            
        #reverse 2nd half    
        second = slow.next
        prev = slow.next = None # we define what next is, with prev
        while second:
            tmp = second.next
            second.next = prev
            prev = second
            second = tmp 
            
            #merge
        first, second = head, prev
        while second:
            tmp1, tmp2 = first.next, second.next
            first.next = second
            second.next = tmp1 
            first, second = tmp1, tmp2


# linear time O(1)
# We're not using extra memory so I assume it's O(1) as well. 
---------------------------------------------------------------------------------------------------
19. Remove Nth Node From End of List

# left pointer, right pointer, nth distance.
# shifting right by same amount of distance, say n=2 
# at the end move the nth node, compared to null, into null to delete it.

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        left = dummy
        right = head 
        
        while n > 0 and right: 
            right =  right.next 
            n -= 1 
            
        while right:
            left = left.next
            right =  right.next
                
                # delete 
        left.next = left.next.next
        return dummy.next 
--------------------------------------------------------------------------------------------------------

141. Linked List Cycle

# Floyds Algorithm
# Tortoise and hare problem
# slow pointer and fast pointer
# Cycle
# -> -> x( )cycle here, meet at x
#if the slow and fast pointer meet return true, if not return false
# they will meet at some point, if there's a cycle, since the cycle has to start somewhere.


141. Linked List Cycle

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        slow, fast = head, head
        
        while fast and fast.next:  ## while fast and fast.next 
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                return True
        return False

----------------------------------

23. Merge k Sorted Lists * 

# merge into pieces
# mege pieces together 
# it becomes like subproblems
# we have our new list 

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists or len(lists) == 0:
            return None

        while len(lists) > 1:
            mergedLists = []
            for i in range(0, len(lists), 2):
                l1 = lists[i]
                l2 = lists[i + 1] if (i + 1) < len(lists) else None
                mergedLists.append(self.mergeList(l1, l2))
            lists = mergedLists
        return lists[0]

    def mergeList(self, l1, l2):
        dummy = ListNode()
        tail = dummy

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        if l1:
            tail.next = l1
        if l2:
            tail.next = l2
        return dummy.next

# Time complexity O(n log k) 

-------------------------------

# swap the children
# compertmentalize into recursive


# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        # swap the children
        
        tmp = root.left  #temporary variable 
        root.left = root.right  # rootleftbecomesrootright
        root.right = tmp # rootright becomes temp 
        
        self.invertTree(root.left) # invert the left root of the tree 
        self.invertTree(root.right) # invert the right root of the tree 
        return root 

------------------------------------------------------------------------
if not root:
    return none

tmp = root.left
roof.left = root.right 
root.right = tmp 

self.invertTree(root.left)
self.invertTree(root.right)
return root 

----------------------------------------------------------------

Invert a binary tree

#BFS
#DFS 
#in-order, post order, doesn't matter
#I prefer DFS and post order 
#add the children to the stack, and their pos/level as we search through

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1]]
        res = 0
        
        while stack:
            node, depth = stack.pop()
            
            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1 ])
        return res

------------------------------------------------------------------

100. Same Tree

time complexity O(p+q)

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
    #dealing with edge cases
        if not p and not q:
            return True
        if not p or not q or  p.val != q.val:
            return False
        
        # AND together, true or false 
        return (self.isSameTree(p.left, q.left) and
        self.isSameTree(p.right, q.right))

        
------------------------------------------------------------------