https://neetcode.io/

Blind75
----------------------
Day 1.

217. Contains duplicate. Use a hash set

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)

or


class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
        hashset = set()

	for n in nums:
		if n in hashset:
			return True
		hashset.add(n)
	return False

1.

class Solution:
	def containsDuplciate(self, nums: List[int]) -> bool:
		hashset = set()

	for in n nums:
		if n in hashset:
			return true
		hashset.add(n)
	return false

Time and space complexity: O(n), O(n)


2.

    def containsDuplicate(self, nums: List[int]) -> bool:
	numset = set(nums)
	return len(numset) != len(nums)




------------------------------------------------------------------

242. Valid Anagram.

Use a hashmap or array.

class Solution:
	def isAnagram(self, s: str, t: str) -> bool:
	return Counter(s) == Counter(t)
	
	if len(s) != len(t):
	return False
	countS, countT = {}, {}
	
	for i in range(len(s)):
	countS[s[i]] = 1 + countS.get(s[i], 0)
	countT[t[i]] = 1 + countT.get(t[i], 0)
	for c in countS:
	if countS[c] != countT.get(c, 0):
	return False

	return True

Time complexity
O(s+t)
Need extra memory.

sorted Counter(s) == Counter(t)


Memory: O(1)
Time complexity: O(n log n)


---------

class solution:
	def twoSum(self, nums: List[int], target: int) -> List[
 	prevMap = {} 


for i, n in enumerate(nums):
	diff = target - n
	if diff in prevMap:
		return [prevMap[diff], i]
	prevMap{n] = i
return



class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        prevMap = {}  # val -> index

        for i, n in enumerate(nums):
            diff = target - n
            if diff in prevMap:
                return [prevMap[diff], i]
            prevMap[n] = i

o(n)
o(n)

---------------
49. group-anagrams

Use a hash map, key:value pair 
count all charachters, key -> which strings have this pattern of count, value, eat, tea, eat
Big of (m*n*26) constant is dropped 
O(m*n)


Class Solution:
	def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
	ans = collections.defaultdict(list)

	for s in strs:
		count = [0] * 26 # Array consisting of all lower case charachters  a...z
		for c in s:
			count[ord(c) - ord('a')] += 1 # mapping a to index 0, mapping z to 25, ascii - lowercase a, 80-80, 81-80...
		ans[tuple(count)].append(s)  # lists cannot be keys, tuples are non mutable
	return ans.values()  # of keys 

	# O(m * n)
	# m, number of strings given
	# n, average length of string 

---------------------------